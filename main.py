from __future__ import annotations
from typing import List, Tuple, Dict, Set, Any
import csv
import networkx as nx
import matplotlib.pyplot as plt
import math
import tkinter as tk
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import webbrowser

#########################
# Core Functionality Module
#########################

SPOTIFY_CLIENT_ID: str = "6ada8de35e21493196ad54d5843e3ddb"  # Your Client ID
SPOTIFY_CLIENT_SECRET: str = "b1950c4a085745a7970d1ff3e590743a"  # Replace with your actual secret
SPOTIFY_REDIRECT_URI: str = "http://127.0.0.1:8080"

sp: spotipy.Spotify = spotipy.Spotify(
    auth_manager=SpotifyOAuth(
        client_id=SPOTIFY_CLIENT_ID,
        client_secret=SPOTIFY_CLIENT_SECRET,
        redirect_uri=SPOTIFY_REDIRECT_URI,
        scope="playlist-modify-public"
    )
)


def create_spotify_playlist(song_name: str, track_ids: List[str]) -> str:
    """
    Create a Spotify playlist based on the provided song name and list of track IDs.

    Preconditions:
        - song_name is a non-empty string.
        - track_ids is a list of valid Spotify track IDs.
        - The Spotify client (sp) must be properly authenticated.

    Representation Invariants:
        - The created playlist is public and its description indicates it was generated by the Song Recommendation System.

    Parameters:
        song_name (str): The base song name for the playlist.
        track_ids (List[str]): A list of Spotify track IDs to include in the playlist.

    Returns:
        str: The external Spotify URL of the created playlist.

    Doctest:
        >>> # Note: This doctest assumes a valid Spotify authentication and may not run in a non-authenticated environment.
        >>> isinstance(create_spotify_playlist("Test Song", ["test_track_id"]), str)
        True
    """
    user_id: str = sp.current_user()["id"]
    playlist: Dict[str, Any] = sp.user_playlist_create(
        user=user_id,
        name=f"Similar to: {song_name}",
        public=True,
        description="Generated by Song Recommendation System"
    )
    sp.playlist_add_items(playlist["id"], track_ids)
    return playlist["external_urls"]["spotify"]


class _Vertex:
    """
    Represents a song vertex in the similarity graph.

    Attributes:
        data (Dict[str, Any]): Dictionary containing song metadata and audio features.
        neighbours (Set[_Vertex]): Set of adjacent vertices representing similar songs.

    Representation Invariants:
        - 'data' must contain keys: 'track_id', 'track_name', 'track_artist', 'danceability', 'energy', 'key',
          'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence',
          'tempo', 'duration_ms', and 'track_popularity'.
        - 'neighbours' is a set of _Vertex objects.
    """

    def __init__(self, data: Dict[str, Any], neighbours: Set[_Vertex]) -> None:
        """
        Initialize a new _Vertex instance.

        Parameters:
            data (Dict[str, Any]): Song metadata and audio features.
            neighbours (Set[_Vertex]): Set of neighbouring vertices.

        Doctest:
            >>> vertex = _Vertex(
            ...     {'track_id': '1', 'track_name': 'Song A', 'track_artist': 'Artist A',
            ...      'danceability': 0.5, 'energy': 0.5, 'key': 5, 'loudness': -30, 'mode': 1,
            ...      'speechiness': 0.1, 'acousticness': 0.3, 'instrumentalness': 0.0,
            ...      'liveness': 0.2, 'valence': 0.4, 'tempo': 120, 'duration_ms': 210000,
            ...      'track_popularity': 50},
            ...     set()
            ... )
            >>> isinstance(vertex, _Vertex)
            True
        """
        self.data: Dict[str, Any] = data
        self.neighbours: Set[_Vertex] = neighbours


def row_to_track_data(row: Dict[str, str]) -> Dict[str, Any]:
    """
    Convert a CSV row into a standardized song dictionary.

    Preconditions:
        - The input 'row' must have the keys: 'track_id', 'track_name', 'track_artist', 'danceability',
          'energy', 'key', 'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness',
          'valence', 'tempo', 'duration_ms', and 'track_popularity'.

    Parameters:
        row (Dict[str, str]): A dictionary representing a CSV row with song data.

    Returns:
        Dict[str, Any]: A dictionary with the song's metadata and numerical audio features appropriately casted.

    Doctest:
        >>> row = {
        ...   'track_id': '1',
        ...   'track_name': 'Song A',
        ...   'track_artist': 'Artist A',
        ...   'danceability': '0.5',
        ...   'energy': '0.5',
        ...   'key': '5',
        ...   'loudness': '-30',
        ...   'mode': '1',
        ...   'speechiness': '0.1',
        ...   'acousticness': '0.3',
        ...   'instrumentalness': '0.0',
        ...   'liveness': '0.2',
        ...   'valence': '0.4',
        ...   'tempo': '120',
        ...   'duration_ms': '210000',
        ...   'track_popularity': '50'
        ... }
        >>> data = row_to_track_data(row)
        >>> data['danceability']
        0.5
    """
    return {
        'track_id': str(row['track_id']),
        'track_name': str(row['track_name']),
        'track_artist': str(row['track_artist']),
        'danceability': float(row['danceability']),
        'energy': float(row['energy']),
        'key': int(row['key']),
        'loudness': float(row['loudness']),
        'mode': int(row['mode']),
        'speechiness': float(row['speechiness']),
        'acousticness': float(row['acousticness']),
        'instrumentalness': float(row['instrumentalness']),
        'liveness': float(row['liveness']),
        'valence': float(row['valence']),
        'tempo': float(row['tempo']),
        'duration_ms': int(row['duration_ms']),
        'track_popularity': int(row['track_popularity'])
    }


class Graph:
    """
    Main graph structure for storing and analyzing song relationships.

    Attributes:
        _vertices (Dict[str, _Vertex]): A dictionary mapping track IDs to _Vertex objects.

    Representation Invariants:
        - Each key in _vertices is a string representing a valid track ID.
        - Each value in _vertices is an instance of _Vertex with properly formatted song data.
    """

    def __init__(self) -> None:
        """
        Initialize an empty Graph.

        Doctest:
            >>> graph = Graph()
            >>> isinstance(graph.vertices, dict)
            True
        """
        self._vertices: Dict[str, _Vertex] = {}

    @property
    def vertices(self) -> Dict[str, _Vertex]:
        """
        Return all vertices in the graph.

        Returns:
            Dict[str, _Vertex]: Dictionary mapping track IDs to _Vertex objects.

        Doctest:
            >>> graph = Graph()
            >>> graph.vertices == {}
            True
        """
        return self._vertices

    def add_vertex(self, song_data: Dict[str, Any]) -> None:
        """
        Add a new song vertex to the graph.

        Preconditions:
            - song_data must include a valid 'track_id' key.
            - song_data must follow the format specified in row_to_track_data.

        Parameters:
            song_data (Dict[str, Any]): Dictionary containing song metadata and audio features.

        Returns:
            None

        Doctest:
            >>> graph = Graph()
            >>> song = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> graph.add_vertex(song)
            >>> '1' in graph.vertices
            True
        """
        song_id: str = str(song_data['track_id'])
        if song_id not in self._vertices:
            self._vertices[song_id] = _Vertex(song_data, set())

    def add_edge(self, track1: str, track2: str) -> None:
        """
        Create an undirected edge between two tracks in the graph.

        Preconditions:
            - Both track1 and track2 must exist in the graph.

        Parameters:
            track1 (str): Track ID of the first song.
            track2 (str): Track ID of the second song.

        Returns:
            None

        Raises:
            ValueError: If one or both of the track IDs are not found in the graph.

        Doctest:
            >>> graph = Graph()
            >>> song_a = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> song_b = {
            ...   'track_id': '2',
            ...   'track_name': 'Song B',
            ...   'track_artist': 'Artist B',
            ...   'danceability': 0.6,
            ...   'energy': 0.6,
            ...   'key': 4,
            ...   'loudness': -28,
            ...   'mode': 1,
            ...   'speechiness': 0.15,
            ...   'acousticness': 0.35,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.25,
            ...   'valence': 0.5,
            ...   'tempo': 130,
            ...   'duration_ms': 200000,
            ...   'track_popularity': 60
            ... }
            >>> graph.add_vertex(song_a)
            >>> graph.add_vertex(song_b)
            >>> graph.add_edge('1', '2')
            >>> len(graph.vertices['1'].neighbours) == 1
            True
        """
        if track1 not in self._vertices or track2 not in self._vertices:
            raise ValueError("Tracks not found")
        v1: _Vertex = self._vertices[track1]
        v2: _Vertex = self._vertices[track2]
        v1.neighbours.add(v2)
        v2.neighbours.add(v1)

    def get_similarity_score(self, v1: _Vertex, v2: _Vertex) -> float:
        """
        Calculate similarity score between two songs based on their audio features.

        Preconditions:
            - Both v1 and v2 must have all required audio feature keys.
            - Features compared include: danceability, energy, key, loudness, mode, speechiness, acousticness,
              instrumentalness, liveness, valence, and tempo.

        Parameters:
            v1 (_Vertex): First song vertex.
            v2 (_Vertex): Second song vertex.

        Returns:
            float: Similarity score between 0 and 1, where 1 indicates identical features.

        Doctest:
            >>> vertex_data = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> v1 = _Vertex(vertex_data, set())
            >>> v2 = _Vertex(vertex_data, set())
            >>> graph = Graph()
            >>> graph.get_similarity_score(v1, v2)
            1.0
        """
        features: List[str] = [
            "danceability", "energy", "key", "loudness", "mode",
            "speechiness", "acousticness", "instrumentalness", "liveness",
            "valence", "tempo",
        ]
        feature_ranges: Dict[str, Tuple[float, float]] = {
            "danceability": (0.0, 1.0),
            "energy": (0.0, 1.0),
            "key": (-1, 11),
            "loudness": (-60, 0),
            "mode": (0, 1),
            "speechiness": (0.0, 1.0),
            "acousticness": (0.0, 1.0),
            "instrumentalness": (0.0, 1.0),
            "liveness": (0.0, 1.0),
            "valence": (0.0, 1.0),
            "tempo": (60, 200),
        }
        diff_squared_sum: float = 0.0
        for feat in features:
            min_val, max_val = feature_ranges[feat]
            range_val: float = max_val - min_val
            v1_val: float = float(v1.data[feat])
            v2_val: float = float(v2.data[feat])
            scaled_v1: float = (v1_val - min_val) / range_val
            scaled_v2: float = (v2_val - min_val) / range_val
            diff_squared_sum += (scaled_v1 - scaled_v2) ** 2
        distance: float = math.sqrt(diff_squared_sum)
        max_distance: float = math.sqrt(len(features))
        similarity: float = 1 - (distance / max_distance)
        return max(0, similarity)

    def get_similarity_scores(self, input_song_id: str) -> List[Tuple[str, float]]:
        """
        Return a sorted list of similarity scores relative to the input song.

        Preconditions:
            - input_song_id must exist in the graph.

        Parameters:
            input_song_id (str): The track ID of the input song.

        Returns:
            List[Tuple[str, float]]: A list of tuples where each tuple contains a track ID and its similarity score,
            sorted in descending order of similarity.

        Doctest:
            >>> # Using a minimal graph with two songs with identical features
            >>> graph = Graph()
            >>> song_data = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> graph.add_vertex(song_data)
            >>> song_data2 = song_data.copy()
            >>> song_data2['track_id'] = '2'
            >>> graph.add_vertex(song_data2)
            >>> scores = graph.get_similarity_scores('1')
            >>> len(scores) == 1
            True
        """
        if input_song_id not in self._vertices:
            raise ValueError("Input song not found")
        input_vertex: _Vertex = self._vertices[input_song_id]
        input_key: Tuple[str, str] = (
            input_vertex.data['track_name'].strip().lower(),
            input_vertex.data['track_artist'].strip().lower()
        )
        seen: Set[Tuple[str, str]] = set()
        scores: List[Tuple[str, float]] = []
        for song_id, vertex in self._vertices.items():
            key: Tuple[str, str] = (
                vertex.data['track_name'].strip().lower(),
                vertex.data['track_artist'].strip().lower()
            )
            if key == input_key or key in seen:
                continue
            scores.append((song_id, self.get_similarity_score(input_vertex, vertex)))
            seen.add(key)
        return sorted(scores, key=lambda x: x[1], reverse=True)

    def get_top_neighbours(self, input_song_id: str, top_n: int = 20) -> Set[str]:
        """
        Get the top N most similar track IDs for the given input song, with duplicate songs removed.

        Preconditions:
            - input_song_id must exist in the graph.
            - top_n should be a positive integer.

        Parameters:
            input_song_id (str): The track ID of the input song.
            top_n (int): The maximum number of similar tracks to return (default is 20).

        Returns:
            Set[str]: A set of track IDs corresponding to the top N most similar songs.

        Doctest:
            >>> graph = Graph()
            >>> song_data = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> graph.add_vertex(song_data)
            >>> song_data2 = song_data.copy()
            >>> song_data2['track_id'] = '2'
            >>> graph.add_vertex(song_data2)
            >>> neighbours = graph.get_top_neighbours('1', top_n=1)
            >>> isinstance(neighbours, set)
            True
        """
        if input_song_id not in self._vertices:
            raise ValueError("Input song not found")
        input_vertex: _Vertex = self._vertices[input_song_id]
        input_key: Tuple[str, str] = (
            input_vertex.data['track_name'].strip().lower(),
            input_vertex.data['track_artist'].strip().lower()
        )
        scores: Dict[str, float] = {
            song_id: self.get_similarity_score(input_vertex, vertex)
            for song_id, vertex in self._vertices.items()
        }
        scores_sorted: Dict[str, float] = dict(sorted(scores.items(), key=lambda item: item[1], reverse=True))
        filtered: List[Tuple[str, float]] = []
        seen: Set[Tuple[str, str]] = set()
        for song_id, score in scores_sorted.items():
            v: _Vertex = self._vertices[song_id]
            key: Tuple[str, str] = (
                v.data['track_name'].strip().lower(),
                v.data['track_artist'].strip().lower()
            )
            if key == input_key or key in seen:
                continue
            seen.add(key)
            filtered.append((song_id, score))
            if len(filtered) >= top_n:
                break
        return {song_id for song_id, _ in filtered}

    def find_song_id_by_name(self, song_name: str) -> str:
        """
        Find and return a song ID by partially matching the song name or artist.

        Preconditions:
            - song_name should be a non-empty string.

        Parameters:
            song_name (str): A partial or full song name to search for.

        Returns:
            str: The track ID of the matched song. If multiple matches are found, the user is prompted to select one.

        Doctest:
            >>> graph = Graph()
            >>> song_data = {
            ...   'track_id': '1',
            ...   'track_name': 'Song A',
            ...   'track_artist': 'Artist A',
            ...   'danceability': 0.5,
            ...   'energy': 0.5,
            ...   'key': 5,
            ...   'loudness': -30,
            ...   'mode': 1,
            ...   'speechiness': 0.1,
            ...   'acousticness': 0.3,
            ...   'instrumentalness': 0.0,
            ...   'liveness': 0.2,
            ...   'valence': 0.4,
            ...   'tempo': 120,
            ...   'duration_ms': 210000,
            ...   'track_popularity': 50
            ... }
            >>> graph.add_vertex(song_data)
            >>> graph.find_song_id_by_name("Song A")
            '1'
        """
        matches: List[Tuple[str, Dict[str, Any]]] = [
            (tid, v.data) for tid, v in self._vertices.items()
            if (song_name.lower() in v.data['track_name'].lower() or
                song_name.lower() in v.data['track_artist'].lower())
        ]
        if not matches:
            raise ValueError(f"No songs found matching: {song_name}")
        unique_matches: Dict[Tuple[str, str], Tuple[str, Dict[str, Any]]] = {}
        for tid, data in matches:
            key: Tuple[str, str] = (data['track_name'].strip().lower(), data['track_artist'].strip().lower())
            if key not in unique_matches:
                unique_matches[key] = (tid, data)
        unique_list: List[Tuple[str, Dict[str, Any]]] = list(unique_matches.values())
        if len(unique_list) > 1:
            print(f"Found {len(unique_list)} unique matching songs:")
            for i, (_, data) in enumerate(unique_list, 1):
                print(f"{i}. {data['track_name']} by {data['track_artist']}")
            while True:
                try:
                    choice: int = int(input("Enter selection number: "))
                    if 1 <= choice <= len(unique_list):
                        return unique_list[choice - 1][0]
                except ValueError:
                    print("Invalid number")
        return unique_list[0][0]


def load_song_graph() -> Graph:
    """
    Load the song graph from the CSV dataset.

    Preconditions:
        - The file "spotify_songs.csv" must exist in the current directory and be properly formatted.

    Returns:
        Graph: A Graph instance populated with songs from the CSV file.

    Doctest:
        >>> # This doctest requires a valid "spotify_songs.csv" file and may not run in a test environment.
        >>> isinstance(load_song_graph(), Graph)
        True
    """
    graph: Graph = Graph()
    with open("spotify_songs.csv", "r", encoding="utf-8") as csvfile:
        reader = csv.DictReader(csvfile)
        songs: List[Dict[str, Any]] = [row_to_track_data(row) for row in reader]
    if len(songs) > 10000:
        songs.sort(key=lambda song: song['track_popularity'])
        songs = songs[10000:]
    for song in songs:
        graph.add_vertex(song)
    return graph


def visualize_focused_graph(graph: Graph, input_song_id: str, threshold: float = 0.9) -> None:
    """
    Visualize the network of similar songs using matplotlib.

    Preconditions:
        - graph must be a valid Graph instance.
        - input_song_id must exist in graph.vertices.
        - threshold should be a float between 0 and 1.

    Parameters:
        graph (Graph): The graph containing song vertices.
        input_song_id (str): The track ID of the input song to focus on.
        threshold (float): Similarity threshold for including songs in the visualization (default 0.9).

    Returns:
        None

    Doctest:
        >>> # This test requires a graphical environment and is not suitable for automated testing.
        >>> # visualize_focused_graph(graph, "1")
        >>> True
    """
    plt.switch_backend('TkAgg')
    scores: List[Tuple[str, float]] = graph.get_similarity_scores(input_song_id)
    selected_nodes: Set[str] = {input_song_id}
    for song_id, sim in scores:
        if sim >= threshold:
            selected_nodes.add(song_id)

    subgraph: nx.Graph = nx.Graph()
    for song_id in selected_nodes:
        vertex: _Vertex = graph.vertices[song_id]
        subgraph.add_node(song_id, **vertex.data)

    selected_list: List[str] = list(selected_nodes)
    for i in range(len(selected_list)):
        for j in range(i + 1, len(selected_list)):
            node_i: str = selected_list[i]
            node_j: str = selected_list[j]
            sim: float = graph.get_similarity_score(graph.vertices[node_i], graph.vertices[node_j])
            edge_threshold: float = 0.9 if (node_i == input_song_id or node_j == input_song_id) else 0.95
            if sim >= edge_threshold:
                subgraph.add_edge(node_i, node_j)

    pos: Dict[Any, Any] = nx.spring_layout(subgraph, k=1.5, iterations=300, seed=42)
    plt.figure(figsize=(20, 16))
    labels: Dict[str, str] = {
        n: (subgraph.nodes[n]['track_name'][:20] + "..."
            if len(subgraph.nodes[n]['track_name']) > 20 else subgraph.nodes[n]['track_name'])
        for n in subgraph.nodes
    }
    colors: List[str] = ['red' if n == input_song_id else 'green' for n in subgraph.nodes]
    nx.draw(subgraph, pos, labels=labels, node_color=colors, node_size=800,
            font_size=7, edge_color='gray', width=0.8, font_weight='bold', alpha=0.9)
    plt.title(f"Songs with similarity >= {int(threshold * 100)}% (Input edges) and >= 95% (Other edges)\n"
              f"to {graph.vertices[input_song_id].data['track_name']}", fontsize=14)
    plt.show(block=False)


def get_unique_songs(graph: Graph) -> List[Tuple[str, str, str]]:
    """
    Return a deduplicated list of songs from the graph.

    Preconditions:
        - graph must be a valid Graph instance.

    Parameters:
        graph (Graph): The graph containing song vertices.

    Returns:
        List[Tuple[str, str, str]]: A list of tuples, each containing (track_id, track_name, track_artist)
        with duplicates removed.

    Doctest:
        >>> graph = Graph()
        >>> song = {
        ...   'track_id': '1',
        ...   'track_name': 'Song A',
        ...   'track_artist': 'Artist A',
        ...   'danceability': 0.5,
        ...   'energy': 0.5,
        ...   'key': 5,
        ...   'loudness': -30,
        ...   'mode': 1,
        ...   'speechiness': 0.1,
        ...   'acousticness': 0.3,
        ...   'instrumentalness': 0.0,
        ...   'liveness': 0.2,
        ...   'valence': 0.4,
        ...   'tempo': 120,
        ...   'duration_ms': 210000,
        ...   'track_popularity': 50
        ... }
        >>> graph.add_vertex(song)
        >>> len(get_unique_songs(graph))
        1
    """
    seen: Dict[Tuple[str, str], Tuple[str, str, str]] = {}
    for tid, vertex in graph.vertices.items():
        key: Tuple[str, str] = (vertex.data['track_name'].strip().lower(), vertex.data['track_artist'].strip().lower())
        if key not in seen:
            seen[key] = (tid, vertex.data['track_name'], vertex.data['track_artist'])
    return list(seen.values())


def run_gui(graph: Graph) -> None:
    """
    Run the Tkinter GUI for song search and recommendations.

    Preconditions:
        - graph must be a valid Graph instance.
        - A graphical display environment is available.

    Parameters:
        graph (Graph): The graph containing song vertices.

    Returns:
        None

    Doctest:
        >>> # This test requires a graphical environment and user interaction, not suitable for automated testing.
        >>> run_gui(Graph())
        >>> True
    """
    unique_songs: List[Tuple[str, str, str]] = get_unique_songs(graph)
    root: tk.Tk = tk.Tk()
    root.title("Song Finder")

    search_var: tk.StringVar = tk.StringVar()
    entry: tk.Entry = tk.Entry(root, textvariable=search_var, width=50)
    entry.pack(pady=10)

    suggestions_listbox: tk.Listbox = tk.Listbox(root, width=50, height=10)
    suggestions_listbox.pack()

    rec_label: tk.Label = tk.Label(root, text="Top 25 Recommendations")
    rec_label.pack(pady=(10, 0))
    recommendations_listbox: tk.Listbox = tk.Listbox(root, width=80, height=25)
    recommendations_listbox.pack(pady=(0, 10))

    def update_suggestions(*args: Any) -> None:
        """
        Update the suggestions in the listbox based on the current search query.

        Parameters:
            *args: Additional arguments provided by the trace callback.

        Returns:
            None
        """
        query: str = search_var.get().strip().lower()
        suggestions_listbox.delete(0, tk.END)
        for tid, name, artist in unique_songs:
            if query in name.lower() or query in artist.lower():
                suggestions_listbox.insert(tk.END, f"{name} - {artist}")

    search_var.trace_add("write", update_suggestions)

    def on_listbox_select(event: Any) -> None:
        """
        Handle the event when a suggestion is selected from the listbox.

        Parameters:
            event: The event object from Tkinter.

        Returns:
            None
        """
        selection = suggestions_listbox.curselection()
        if selection:
            index: int = selection[0]
            value: str = suggestions_listbox.get(index)
            search_var.set(value)

    suggestions_listbox.bind('<<ListboxSelect>>', on_listbox_select)

    def open_playlist(event: Any) -> None:
        """
        Open the Spotify playlist URL when a recommendation is double-clicked.

        Preconditions:
            - The selected item in the recommendations listbox starts with "ðŸŽµ Playlist created: ".

        Parameters:
            event: The event object from Tkinter.

        Returns:
            None
        """
        selection = recommendations_listbox.curselection()
        if selection:
            index: int = selection[0]
            item_text: str = recommendations_listbox.get(index)
            if item_text.startswith("ðŸŽµ Playlist created: "):
                url: str = item_text.split("ðŸŽµ Playlist created: ")[-1].strip()
                webbrowser.open(url)

    recommendations_listbox.bind('<Double-Button-1>', open_playlist)

    def select_song() -> None:
        """
        Process the selected song from the search box and display recommendations.

        Preconditions:
            - The song selected must match an entry in the unique_songs list.

        Returns:
            None

        Doctest:
            >>> # This test requires user interaction and Spotify API access, not suitable for automated testing.
            >>> select_song()
            >>> True
        """
        query: str = search_var.get().strip()
        for tid, name, artist in unique_songs:
            if f"{name} - {artist}" == query:
                scores: List[Tuple[str, float]] = graph.get_similarity_scores(tid)[:25]
                recommendations_listbox.delete(0, tk.END)
                recommendations_listbox.insert(tk.END, f"Selected: {name} - {artist}")
                recommendations_listbox.insert(tk.END, "----------------------------------------")
                track_ids: List[str] = []
                for sid, score in scores:
                    track: Dict[str, Any] = graph.vertices[sid].data
                    result: Dict[str, Any] = sp.search(
                        q=f"track:{track['track_name']} artist:{track['track_artist']}",
                        type="track",
                        limit=1
                    )
                    if result["tracks"]["items"]:
                        track_ids.append(result["tracks"]["items"][0]["id"])
                    else:
                        print(f"Not found on Spotify: {track['track_name']} - {track['track_artist']}")
                    recommendations_listbox.insert(
                        tk.END,
                        f"{track['track_name']} - {track['track_artist']} | Similarity Rate: {int(score * 100)}%"
                    )

                playlist_url: str = create_spotify_playlist(name, track_ids)
                recommendations_listbox.insert(tk.END, "----------------------------------------")
                recommendations_listbox.insert(tk.END, f"ðŸŽµ Playlist created: {playlist_url}")

                visualize_focused_graph(graph, tid, threshold=0.9)
                return
        recommendations_listbox.delete(0, tk.END)
        recommendations_listbox.insert(tk.END, "Song not found. Please select from the suggestions.")

    btn: tk.Button = tk.Button(root, text="Select Song", command=select_song)
    btn.pack(pady=10)
    root.mainloop()


def main() -> None:
    """
    Main entry point for the song recommendation system application.

    Preconditions:
        - The file "spotify_songs.csv" must exist and be properly formatted.
        - A valid Spotify authentication session must be established.

    Returns:
        None

    Doctest:
        >>> # Running main() will launch the GUI and is not suitable for automated testing.
        >>> main()
    """
    try:
        song_graph: Graph = load_song_graph()
        run_gui(song_graph)
    except Exception as e:
        print(f"Error: {e}")


if __name__ == '__main__':
    main()

